"""

# ACCORDING TO CERN VACUUM TECHNICAL NOTE 96-01 (1996) THE CROSS SECTIONS OF PARTICLES IN THE HIGH ENERGY REGIME
# ONLY DEPENDS ON THE ENERGY, NOT ON THE EXACT PARAMETERS (LIKE CHARGE). THUS  THE CROSS SECTION GENERATED BY
# 7TeV PROTONS IS EQUAL TO THE ONE OF 3.81GeV ELECTRONS. THUS AN ADAPTED VERSION OF THE BINARY ENCOUNTER BETHE
# VRIENS MODEL IS USED TO DETERMINE THE DIFFERENTIAL CROSS SECTION, self.w_max, WHOSE ANALYTICAL FORM CAN BE
# INTEGRATED AS BELOW, TO OBTAIN THE TOTAL CROSS SECTION.

Author :    Kyle Poland
Sources :   Binary-encounter-dipole model for electron-impact ionization
            ( https://journals.aps.org/pra/pdf/10.1103/PhysRevA.50.3954 )

"""

import numpy as np
import math
import mpmath as mp


class Atom(object):
    def __init__(self, calc_method, Z, B, N, Ni, Mi, ai_below, ai_above, U_bed, M_squared, C, corr_fact):
        """
        :param B:           Bound electron binding energy in eV w.r.t the shell
        :param N:           Total occupation number of requested atom w.r.t the shell
        :param Ni:          Values of Ni for requested atom, for each subshell
        :param Mi:          Values of Mi for requested atom, for each subshell
        :param ai_below:    Coefficients in a 7-th order fit for dipole oscillator strength for
                            energies below 2s ionization energy of (originally scaled via units of bounding energy)
        :param ai_above:    Coefficients in a 7-th order fit for dipole oscillator strength for
                            energies above 2s ionization energy of (originally scaled via units of bounding energy)
        :param U_bed:       Bound electron kinetic energy in eV in the BED model
        """
        self.calc_method = calc_method
        self.Z = Z
        self.B = B
        self.N = N
        self.Ni = Ni
        self.Mi = Mi
        self.ai_below = ai_below
        self.ai_above = ai_above
        self.U_bed = U_bed
        self.M_squared = M_squared
        self.C = C
        self.corr_fact = corr_fact


class AtomFactory(object):
    """
    Generate instances with atom properties
    """

    @staticmethod
    def get_hydrogen():
        calc_method = 'bed'
        Z = 1.
        B = np.array([(13.6057)])
        N = np.array([(1)])

        Ni = np.array([(0.4343)])
        Mi = np.array([(0.2834)])

        ai_below_2s_ion_threshold = np.array(
            [0.0, -2.2473e-2, 1.1775, -4.6264e-1, 8.9064e-2, 0.0, 0.0]
        )

        ai_above_2s_ion_threshold = np.array(
            [0.0, -2.2473e-2, 1.1775, -4.6264e-1, 8.9064e-2, 0.0, 0.0]
        )

        U_bed = np.array([(13.6057)])

        M_squared = 0.695

        C = 8.115

        corr_fact = 1.2

        return Atom(
            calc_method, Z, B, N, Ni, Mi, ai_below_2s_ion_threshold, ai_above_2s_ion_threshold, U_bed, M_squared, C, corr_fact
        )

    @staticmethod
    def get_h2():
        calc_method = 'bed'
        Z = 2.
        B = np.array([(1.543e1)])
        N = np.array([(2)])

        Ni = np.array([1.173])
        Mi = np.array([0.68])

        ai_below_2s_ion_threshold = np.array(
            [0.0, 0.0, 1.1262, 6.3982, -7.8055, 2.144, 0.0]
        )

        ai_above_2s_ion_threshold = np.array(
            [0.0, 0.0, 1.1262, 6.3982, -7.8055, 2.144, 0.0]
        )

        U_bed = np.array([2.568e1])

        M_squared = 0.695

        C = 8.115

        corr_fact = 1.2

        return Atom(
            calc_method, Z, B, N, Ni, Mi, ai_below_2s_ion_threshold, ai_above_2s_ion_threshold, U_bed, M_squared, C, corr_fact
        )

    @staticmethod
    def get_helium():
        calc_method = 'bed'
        Z = 2.
        B = np.array([(2.459e1)])
        N = np.array([(2)])

        Ni = np.array([(1.605)])
        Mi = np.array([(0.489)])

        ai_below_2s_ion_threshold = np.array(
            [0.0, 0.0, 1.2178e1, -2.9585e1, 3.1251e1, -1.2175e1, 0.0]
        )

        ai_above_2s_ion_threshold = np.array(
            [0.0, 0.0, 1.2178e1, -2.9585e1, 3.1251e1, -1.2175e1, 0.0]
        )

        U_bed = np.array([(3.951e1)])

        M_squared = 0.752

        C = 7.571

        corr_fact = 1.2

        return Atom(
            calc_method, Z, B, N, Ni, Mi, ai_below_2s_ion_threshold, ai_above_2s_ion_threshold, U_bed, M_squared, C, corr_fact
        )

    @staticmethod
    def get_neon():
        calc_method = 'bed'
        Z = 10.
        B = np.array([21.7, 48.47, 866.9])
        N = np.array([6, 2, 2])

        Ni = np.array([6.963, 0.7056, 1.686])
        Mi = np.array([1.552, 4.8e-2, 1.642e-2])

        ai_below_2s_ion_threshold = np.array(
            [
                [4.8791, -2.882, -7.4711e-1, 0.0, 0.0, 0.0, 0.0],
                [0.0, 1.7769, 2.8135, -3.151e1, 6.3469e1, -5.2528e1, 1.5982e1],
                [0.0, 0.0, 5.2475, -2.8121, 0.0, 0.0, 0.0],
            ]
        )

        ai_above_2s_ion_threshold = np.array(
            [
                [0.0, -5.8514, 3.2930e2, -1.6788e3, 3.2985e3, -2.3250e3, 0.0],
                [0.0, 1.7769, 2.8135, -3.151e1, 6.3469e1, -5.2528e1, 1.5982e1],
                [0.0, 0.0, 5.2475, -2.8121, 0.0, 0.0, 0.0],
            ]
        )

        U_bed = np.array([1.1602e2, 1.4188e2, 1.2591e3])

        M_squared = 2.02

        C = 18.17

        corr_fact = 1.2

        return Atom(
            calc_method, Z, B, N, Ni, Mi, ai_below_2s_ion_threshold, ai_above_2s_ion_threshold, U_bed, M_squared, C, corr_fact
        )

    @staticmethod
    def get_nitrogen():
        calc_method = 'beb'
        Z = 10.
        B = np.array([21.7, 48.47, 866.9])
        N = np.array([6, 2, 2])

        Ni = np.array([6.963, 0.7056, 1.686])
        Mi = np.array([1.552, 4.8e-2, 1.642e-2])

        ai_below_2s_ion_threshold = np.array(
            [
                [4.8791, -2.882, -7.4711e-1, 0.0, 0.0, 0.0, 0.0],
                [0.0, 1.7769, 2.8135, -3.151e1, 6.3469e1, -5.2528e1, 1.5982e1],
                [0.0, 0.0, 5.2475, -2.8121, 0.0, 0.0, 0.0],
            ]
        )

        ai_above_2s_ion_threshold = np.array(
            [
                [0.0, -5.8514, 3.2930e2, -1.6788e3, 3.2985e3, -2.3250e3, 0.0],
                [0.0, 1.7769, 2.8135, -3.151e1, 6.3469e1, -5.2528e1, 1.5982e1],
                [0.0, 0.0, 5.2475, -2.8121, 0.0, 0.0, 0.0],
            ]
        )

        U_bed = np.array([1.1602e2, 1.4188e2, 1.2591e3])

        M_squared = 2.02

        C = 18.17

        corr_fact = 1.2

        return Atom(
            Z, B, N, Ni, Mi, ai_below_2s_ion_threshold, ai_above_2s_ion_threshold, U_bed, M_squared, C, corr_fact
        )


class CrossSectionCalc:
    m_e = 9.11e-31  # Electron mass in kg
    c = 2.998e8  # Speed of light in m/s
    a_0 = 5.29e-11  # Bohr radius in m
    alpha = 1. / 137.  # Fine structure constant
    R = 13.6  # Rydberg constant in eV

    def __init__(self, T, atom=AtomFactory.get_neon()):
        self.atom = atom
        self.e_charge = 1.6e-19
        self.rest_en_eV = (self.c ** 2) * self.m_e / self.e_charge
        self.T_rel = T #(1. - 1./((T) / self.rest_en_eV) ** 2 ) ** (1. / 2.)
        self.T = self.rest_en_eV/2. * (1. - (self.rest_en_eV / (self.T_rel + self.rest_en_eV)) ** 2.)
        self.t = self.T / atom.B  # T in units of binding energy(vector with entries for each subshell)
        self.w_max = (self.t - (1)) / (2)
        self.u = self.atom.U_bed / self.atom.B  # Constant factor from derivation
        self.S = 4 * (np.pi) * self.a_0 ** 2 * self.atom.N * (self.R / self.atom.B) ** 2



class CrossSectionCalcBed(CrossSectionCalc):
    def __init__(self, T, atom=AtomFactory.get_neon()):
        CrossSectionCalc.__init__(self, T, atom)

    def calculate_modified_oscillator_strength(self, w, n_shell):
        """
        Example:
        >>> calc = CrossSectionCalcBed(1.4e8, atom = AtomFactory.get_neon())
        >>> w = calc.w_max[2]
        >>> calc.calculate_modified_oscillator_strength(w, 2)
        """
        threshold = ((w) + 1.0) * self.atom.B[n_shell]
        coefficient_matrix = (
            self.atom.ai_below if threshold < (48.47) else self.atom.ai_above
        )
        quotient = [1 / ((w) + (1.0)) ** i for i in range(1, 8)]
        osc_str = np.reshape(np.dot(coefficient_matrix, np.array(quotient)), (len(self.atom.B)))
        return 1 / (w + 1) * osc_str[n_shell]

    def calculate(self):
        """
        Example:
        >>> calc = CrossSectionCalcBed(1.4e8, atom = AtomFactory.get_neon())
        >>> calc.calculate_bed()*2.
        """
        integrated_cross_sec_subshells = np.zeros(len(self.w_max))
        for n_shell in range(len(self.w_max)):
            u = self.u[n_shell]
            S = self.S[n_shell]

            factor = S / (self.t[n_shell] + u + 1.0)

            sub_factor1_1 = 2.0 - (self.atom.Ni[n_shell] / self.atom.N[n_shell])
            sub_factor1_2 = (self.t[n_shell] - 1.0) / self.t[n_shell] - np.log(self.t[n_shell]) / (self.t[n_shell] + 1.)
            summand1 = sub_factor1_1 * sub_factor1_2
            integrated_cross_sec_subshells[n_shell] = mp.quad(
                lambda w: self.calculate_modified_oscillator_strength(w, n_shell), [0., self.w_max[n_shell]]
            )

            factor2 = np.log(self.t[n_shell]) / self.atom.N[n_shell]
            integrated_cross_sec_subshells[n_shell] *= factor2
            integrated_cross_sec_subshells[n_shell] += summand1
            integrated_cross_sec_subshells[n_shell] *= factor

        total_cross_section_bed = np.sum(integrated_cross_sec_subshells)

        return (total_cross_section_bed) * 1.e4

    def bethe_asymptotic(self):
        """
        Example
        >>> bethe = CrossSectionCalcBed(1.4e7, atom=AtomFactory.get_helium())
        >>> bethe.bethe_asymptotic()
        """

        cross_section_vec = np.zeros(len(self.w_max))
        for n_shell in range(len(self.w_max)):

            S = self.S[n_shell]
            factor1 = (S) / (self.t[n_shell])
            factor2 = np.log(self.t[n_shell]) / self.atom.N[n_shell]

            cross_section_vec[n_shell] += mp.quad(
                lambda w: self.calculate_modified_oscillator_strength(w, n_shell), [0., self.w_max[n_shell]]
            )

            cross_section_vec[n_shell] *= factor1 * factor2
        cross_section_bethe = np.sum(cross_section_vec)
        return cross_section_bethe * 1.e4

    def Mi_calculation(self, lower_boundary, upper_boundary, n_shell):
        """
        Example:
        >>> calc = CrossSectionCalcBed(3.81e9, atom = AtomFactory.get_neon())
        >>> calc.Mi_calculation(0., 1e9, 2)
        """
        Mi_n_shell = mp.quad(lambda w: self.calculate_modified_oscillator_strength(w, n_shell),
                             [lower_boundary, upper_boundary])
        Mi_n_shell *= self.R / self.atom.B[n_shell]
        return Mi_n_shell


class CrossSectionCalcBeb(CrossSectionCalc):
    def __init__(self, T, atom=AtomFactory.get_neon()):
        CrossSectionCalc.__init__(self, T, atom)
        self.Q = 1.

    def calculate(self):
        """
        Calculate ionization cross section acording to the BEB model, which is a simplified model of the BED ansatz
        >>> calcBeb = CrossSectionCalcBeb(3.81e9, atom = AtomFactory.get_h2())
        >>> calcBeb.calculate()
        """

        integrated_cross_sec_subshells = np.zeros(len(self.w_max))
        for n_shell in range(len(self.w_max)):
            u = self.u[n_shell]
            S = self.S[n_shell]
            factor = S / (self.t[n_shell] + u + 1.0)

            sub_factor1_1 = self.Q / 2
            sub_factor1_2 = (1. - 1. / (self.t[n_shell]) ** 2) * np.log(self.t[n_shell])
            summand1 = sub_factor1_1 * sub_factor1_2

            sub_factor2_1 = 2.0 - self.Q
            sub_factor2_2 = (self.t[n_shell] - 1.0) / self.t[n_shell] - np.log(self.t[n_shell]) / (self.t[n_shell] + 1.)
            summand2 = sub_factor2_1 * sub_factor2_2

            integrated_cross_sec_subshells[n_shell] += summand1 + summand2
            integrated_cross_sec_subshells[n_shell] *= factor

        total_cross_section_bed = np.sum(integrated_cross_sec_subshells)

        return (total_cross_section_bed) * 1.e4

'''
Old models whose behaviour couldn't be argued to be plausible due to assumptions which contradict the situation 
this cross section calculation implementation was meant to treat.


class CrossSectionCalcVacNote(CrossSectionCalc):
    def __init__(self, T, atom=AtomFactory.get_neon()):
        CrossSectionCalc.__init__(self, T, atom)

    def calculate(self):
        """
        Example
        >>> en = 0.1
        >>> Atom = AtomFactory.get_h2()
        >>> calc = CrossSectionCalcVacNote(en, atom = Atom)
        >>> calc2 = CrossSectionCalcBed(en, atom = Atom)
        >>> calc.calculate()
        :return:
        """
        M_squared = self.atom.M_squared
        C = self.atom.C
        correction_factor = self.atom.corr_fact
        en_rest = self.rest_en_eV
        beta = (2./self.rest_en_eV * self.T) ** (1./2.)#(1. - (self.rest_en_eV / ((self.T_rel + self.rest_en_eV))) ** 2.) ** (1. / 2.)
        gamma = beta / (1. - beta ** 2.) ** (1. / 2.)
        x = 2. * math.log(gamma) - beta ** 2.
        omega = 1.874e-24 * (1 / beta) ** 2. * (M_squared * x + C)
        omega *= correction_factor  # Correction factor extrapolated from measurements at 26GeV
        omega *= math.exp( - 1./(self.c ** 2. - self.c **2. * beta ** 2.))
        return omega * 1.e4  # from m^2 to cm^2


class CrossSectionCalcBebvm(CrossSectionCalc):
    def __init__(self, T, atom=AtomFactory.get_neon()):
        CrossSectionCalc.__init__(self, T, atom)
        self.bbar = atom.B / (self.m_e * self.c ** 2)
        self.ubar = atom.U_bed / (self.m_e * self.c ** 2)
        self.beta_b = 1 - 1 / (1 + self.bbar) ** 2
        self.beta_u = 1 - 1 / (1 + self.ubar) ** 2
        self.tbar = self.T / (self.m_e * self.c ** 2)
        self.beta_t = 1 - 1 / (1 + self.tbar) ** 2
        array_elems = [np.log(elem) for elem in (self.beta_t / self.beta_b)]
        value = np.sqrt(
            self.alpha ** 2 / (self.beta_t + self.beta_b) * np.array(array_elems)
        )
        self.phi = np.cos(value)
        self.f_2 = (
                -self.phi / (self.t + 1) * (1 + 2 * self.tbar) / (1 + self.tbar / 2) ** 2
        )
        self.f_3 = (
                np.log(self.beta_t * (1 + self.tbar) ** 2)
                - self.beta_t
                - (2 * np.array([np.log(elem) for elem in self.bbar]))
        )

'''