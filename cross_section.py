"""

# ACCORDING TO CERN VACUUM TECHNICAL NOTE 96-01 (1996) THE CROSS SECTIONS OF PARTICLES IN THE HIGH ENERGY REGIME
# ONLY DEPENDS ON THE ENERGY, NOT ON THE EXACT PARAMETERS (LIKE CHARGE). THUS  THE CROSS SECTION GENERATED BY
# 7TeV PROTONS IS EQUAL TO THE ONE OF 3.81GeV ELECTRONS. THUS AN ADAPTED VERSION OF THE BINARY ENCOUNTER BETHE
# VRIENS MODEL IS USED TO DETERMINE THE DIFFERENTIAL CROSS SECTION, self.w_max, WHOSE ANALYTICAL FORM CAN BE
# INTEGRATED AS BELOW, TO OBTAIN THE TOTAL CROSS SECTION.

Author :    Kyle Poland
Sources :   Binary-encounter-dipole model for electron-impact ionization
            ( https://journals.aps.org/pra/pdf/10.1103/PhysRevA.50.3954 )

"""

import numpy as np
import math
from scipy.integrate import quad
from decimal import *

getcontext().prec = 45


def decimalCos(n):
    return Decimal(1.0) - n ** 2 / Decimal(2.0) + n ** 4 / Decimal(24.0) - \
           n ** 6 / Decimal(720.0) + n ** 8 / Decimal(40320.0)


class Atom(object):
    def __init__(self, B, N, Ni, Mi, ai_below, ai_above, U_bed):
        """
        :param B:           Bound electron binding energy in eV w.r.t the shell
        :param N:           Total occupation number of requested atom w.r.t the shell
        :param Ni:          Values of Ni for requested atom, for each subshell
        :param Mi:          Values of Mi for requested atom, for each subshell
        :param ai_below:    Coefficients in a 7-th order fit for dipole oscillator strength for
                            energies below 2s ionization energy of (originally scaled via units of bounding energy)
        :param ai_above:    Coefficients in a 7-th order fit for dipole oscillator strength for
                            energies above 2s ionization energy of (originally scaled via units of bounding energy)
        :param U_bed:       Bound electron kinetic energy in eV in the BED model
        """

        self.B = B
        self.N = N
        self.Ni = Ni
        self.Mi = Mi
        self.ai_below = ai_below
        self.ai_above = ai_above
        self.U_bed = U_bed


class AtomFactory(object):
    """
    Generate instances with atom properties
    """

    @staticmethod
    def get_neon():
        B = np.array(map(Decimal, [21.7, 48.47, 866.9]))
        N = np.array(map(Decimal, [6, 2, 2]))

        Ni = np.array(map(Decimal, [6.963, 0.7056, 1.686]))
        Mi = np.array(map(Decimal, [1.552, 4.8e-2, 1.642e-2]))

        ai_below_2s_ion_threshold = np.array(
            [
                [4.8791, -2.882, -7.4711e-1, 0.0, 0.0, 0.0, 0.0],
                [0.0, 1.7769, 2.8135, -3.151e1, 6.3469e1, -5.2528e1, 1.5982e1],
                [0.0, 0.0, 5.2475, -2.8121, 0.0, 0.0, 0.0],
            ]
        )

        ai_below_2s_ion_threshold = np.array(
            [map(
                Decimal, ai_below_2s_ion_threshold[i]) for i in range(len(ai_below_2s_ion_threshold))
            ]
        )

        ai_above_2s_ion_threshold = np.array(
            [
                [0.0, -5.8514, 3.2930e2, -1.6788e3, 3.2985e3, -2.3250e3, 0.0],
                [0.0, 1.7769, 2.8135, -3.151e1, 6.3469e1, -5.2528e1, 1.5982e1],
                [0.0, 0.0, 5.2475, -2.8121, 0.0, 0.0, 0.0],
            ]
        )

        ai_above_2s_ion_threshold = np.array(
            [map(
                Decimal, ai_above_2s_ion_threshold[i]) for i in range(len(ai_above_2s_ion_threshold))
            ]
        )

        U_bed = np.array(map(Decimal, [1.1602e2, 1.4188e2, 1.2591e3]))

        return Atom(
            B, N, Ni, Mi, ai_below_2s_ion_threshold, ai_above_2s_ion_threshold, U_bed
        )

    @staticmethod
    def get_hydrogen():
        B = np.array([Decimal(13.6057)])
        N = np.array([Decimal(1)])

        Ni = np.array([Decimal(0.4343)])
        Mi = np.array([Decimal(0.2834)])

        ai_below_2s_ion_threshold = np.array(
            map(
                Decimal, [0.0, -2.2473e-2, 1.1775, -4.6264e-1, 8.9064e-2, 0.0, 0.0]
            )
        )

        ai_above_2s_ion_threshold = np.array(
            map(
                Decimal, [0.0, -2.2473e-2, 1.1775, -4.6264e-1, 8.9064e-2, 0.0, 0.0]
            )
        )

        U_bed = np.array([Decimal(13.6057)])

        return Atom(
            B, N, Ni, Mi, ai_below_2s_ion_threshold, ai_above_2s_ion_threshold, U_bed
        )

    @staticmethod
    def get_helium():
        B = np.array([Decimal(2.459e1)])
        N = np.array([Decimal(2)])

        Ni = np.array([Decimal(1.605)])
        Mi = np.array([Decimal(0.489)])

        ai_below_2s_ion_threshold = np.array(
            map(
                Decimal, [0.0, 0.0, 1.2178e1, -2.9585e1, 3.1251e1, -1.2175e1, 0.0]
            )
        )

        ai_above_2s_ion_threshold = np.array(
            map(
                Decimal, [0.0, 0.0, 1.2178e1, -2.9585e1, 3.1251e1, -1.2175e1, 0.0]
            )
        )

        U_bed = np.array([Decimal(3.951e1)])

        return Atom(
            B, N, Ni, Mi, ai_below_2s_ion_threshold, ai_above_2s_ion_threshold, U_bed
        )


class CrossSectionCalc:
    m_e = Decimal(9.11e-31)  # Electron mass in kg
    c = Decimal(3e8)  # Speed of light in m/s
    a_0 = Decimal(5.29e-11)  # Bohr radius in m
    alpha = Decimal(1.0 / 137)  # Fine structure constant
    R = Decimal(13.6)  # Rydberg constant in eV

    def __init__(self, T, atom=AtomFactory.get_neon()):
        self.atom = atom
        self.T = Decimal(T) * Decimal(1e6)
        self.w_max = ((self.T + atom.U_bed) / self.atom.B - Decimal(1)) / Decimal(2)
        self.t = (
                self.T / atom.B
        )  # T in units of binding energy(vector with entries for each subshell)

    '''
    def total_cross_section_bebvm(self):

        """

        # INTEGRATED VERSION OF BEBVM INTEGRATED FROM A FINAL EJECTED KINETIC ENERGY OF 0 TO w_max = ( (T + U) / B - 1 ) / 2
        # TO OBTAIN TOTAL CROSS SECTION. ORIGINAL FORM OF THE DIFFERENTIAL CROSS SECTION:
        # d_sigma/d_w = f_1 * ( f_2 * (1 / (w + 1) + 1 / (t - w)) + 1 / (w + 1)**2 +
        # + 1 / (t - w)**2 + bbar**2 / (1 + tbar / 2)**2 + f_3 * (1 / (w + 1)**3 + 1 / (t - w)**3) )

        :return: Integrated cross section calculated with the BEBVM model

        """
        f_1 = (
            Decimal(4.0)
            * np.pi
            * self.alpha ** Decimal(4.0)
            * self.a_0 ** Decimal(2.0)
            * self.atom.N
            / (Decimal(2.0) * self.bbar * (self.beta_t + (self.beta_b + self.beta_u)) / Decimal(2.0))
        )
        total_cross_sec = np.sum(
            f_1
            * (
                self.f_2 * np.array([elem.ln() for elem in ((self.w_max + Decimal(1.0)) / (self.t - self.w_max) * self.t)])
                - Decimal(1) / (self.w_max + Decimal(1.0))
                + Decimal(1.0)
                + Decimal(1.0) / (self.t - self.w_max)
                - Decimal(1.0) / self.t
                + self.bbar ** 2 * self.w_max / (Decimal(1.) + self.tbar / Decimal(2.0)) ** 2
                + self.f_3
                / Decimal(2.0)
                * (
                    Decimal(1) / (self.t - self.w_max) ** 2
                    - Decimal(1) / self.t ** Decimal(2.0)
                    - Decimal(1) / (self.w_max + Decimal(1.0)) ** 2
                    + Decimal(1)
                )
            )
        )
        return Decimal(1.0e4) * Decimal(total_cross_sec)


    def differential_cross_section_subshells_bed(self, w_var, n_shell):
        w = Decimal(w_var)
        # Current kinetic energy of electrons in respective shell(n_shell) in units of the binding energy
        u = self.atom.U_bed[n_shell] / self.atom.B[n_shell]
        # different coefficients for different energy regimes, W+U-B hereby corresponds to the
        ai = (
            self.atom.ai_below
            if (w + u - Decimal(1.0)) * self.atom.B[n_shell] < Decimal(48.47)
            else self.atom.ai_above
        )
        osc_str_vec = np.dot(
            ai, np.array([-1 / (w + u - Decimal(1.0)) ** (i + 2) for i in range(7)])
        )

        osc_str = np.reshape(osc_str_vec, (len(self.atom.B)))[n_shell]

        # Vector with corresponding cross sections for ionization from every
        # subshell
        diff_cross_sec_subshell_n = self._calculate_diff_cross_sec_subshell_n(n_shell, u, w, osc_str)

        return diff_cross_sec_subshell_n

    def total_cross_section_bed(self):
        """
        Calculate the cross section binary encouter dipole

        Example:
        >>> calc = CrossSectionCalc(3810, atom= AtomFactory.get_neon())
        >>> calc.total_cross_section_bed()
        4.007883837878639e-18

        :return: Total integrated cross section
        """

        integrated_cross_sec_subshells = np.zeros(len(self.w_max))
        for i in range(len(self.w_max)):
            integrated_cross_sec_subshells[i] = quad(
                self.differential_cross_section_subshells_bed,
                Decimal(0.),
                self.w_max[i],
                args=(i),
            )[0]
        total_cross_section_bed = np.sum(integrated_cross_sec_subshells)

        return Decimal(1.0e4) * Decimal(total_cross_section_bed)  # Converting from m**2 to cm**2

def _calculate_diff_cross_sec_subshell_n(self, n_shell, u, w, osc_str):
        """
        Helper function to calculate the integral of my ass

        :param n_shell:
        :param u:
        :param w:
        :param osc_str:
        :return:
        """
        return (
                self.f_1_bed
                / (self.t + u + Decimal(1.0))
                * (
                        (self.atom.Ni / self.atom.N - Decimal(2.0))
                        / (self.t + Decimal(1.0))
                        * (Decimal(1.0) / (w + Decimal(1.0)) + Decimal(1.0) / (self.t - w))
                        + (Decimal(2.0) - self.atom.Ni / self.atom.N)
                        * (Decimal(1.0) / (self.t - w) ** 2 + Decimal(1.0) / (w + Decimal(1.0)) ** 2)
                        + np.array([elem.ln() for elem in self.t]) / self.atom.N
                        * np.dot(Decimal(1.0) / (w + Decimal(1.0)), osc_str)
                )
        )[n_shell]

    def integ(self, a, b, n_sample, shell = 0):
        x_vals = np.linspace(a, b, num = n_sample)
        dx = (Decimal(b) - Decimal(a)) / Decimal(n_sample)
        integral = Decimal(0)
        for x in x_vals:
            integral += (Decimal(x))**2 * dx #self.differential_cross_section_subshells_bed(x, shell) * dx
        return integral

    def integ2(self, a, b, dx_initial, shell = 0):
        dx = Decimal(dx_initial)
        x = Decimal(a)
        integral = Decimal(0)
        while x <= b:
            delta_integral = Decimal(x + dx / 2)**2 * dx  #self.differential_cross_section_subshells_bed(x, shell) * dx
            integral += delta_integral
            dx /= delta_integral
            x += dx
        return integral

    '''


class CrossSectionCalcBed(CrossSectionCalc):
    def __init__(self, T, atom=AtomFactory.get_neon()):
        CrossSectionCalc.__init__(self, T, atom)
        self.u = self.atom.U_bed / self.atom.B  # Constant factor from derivation

    def calculate(self):
        """
        Calculate the cross section binary encouter dipole

        Example:
        >>> calc = CrossSectionCalcBed(3810, atom= AtomFactory.get_neon())
        >>> calc.calculate()

        4.007883837878639e-18

        :return: Total integrated cross section
        """

        integrated_cross_sec_subshells = np.zeros(len(self.w_max))
        for i in range(len(self.w_max)):
            integrated_cross_sec_subshells[i] = quad(
                self.SDCS,
                Decimal(0.),
                self.w_max[i],
                args=(i),
            )[0]
        total_cross_section_bed = np.sum(integrated_cross_sec_subshells)

        return Decimal(1.0e4) * Decimal(total_cross_section_bed)  # Converting from m**2 to cm**2

    def calculate_oscillator_strength(self, w, n_shell):
        """
        Example:
        >>> calc = CrossSectionCalcBed(3810)
        >>> w = 4
        >>> calc.calculate_oscillator_strength(w, 0)
        :param w:
        :param n_shell:
        :return:
        """
        treshold = (Decimal(w) + self.u[n_shell] - Decimal(1.0)) * self.atom.B[n_shell]
        coefficient_matrix = self.atom.ai_below if treshold < Decimal(48.47) else self.atom.ai_above
        quotient = [-1 / (Decimal(w) + self.u[n_shell] - Decimal(1.0)) ** (i + 2) for i in range(7)]
        osc_str_vec = np.dot(coefficient_matrix, np.array(quotient))
        # TODO check why the fuck he did that
        return np.reshape(osc_str_vec, (len(self.atom.B)))[n_shell]

    def SDCS(self, w, n_shell):
        """"
        Single differential cross section

        Example:
        >>> calc = CrossSectionCalcBed(3810)
        >>> w = 30000
        >>> calc.SDCS(w, 0)
        array([Decimal('-6.62866638228305761587815663304734428699745896E-43'),
               Decimal('2.10867093099800235595671896266577978741435511E-27'),
               Decimal('3.77141394254224385777721363298093896835050815E-26')],
              dtype=object)
        >>> quad(calc.SDCS, 0, 3000, args=(0))
        """
        u = self.atom.U_bed[n_shell] / self.atom.B[n_shell]
        S = Decimal(4) * Decimal(np.pi) * self.a_0 ** 2 * self.atom.N[n_shell] * (self.R / self.atom.B[n_shell]) ** 2
        oscillator_strength = self.calculate_oscillator_strength(w, n_shell)

        factor = S / (self.t + u + Decimal(1.0))

        sub_factor1_1 = (self.atom.Ni[n_shell] / self.atom.N[n_shell]) - Decimal(2.0) / (self.t[n_shell] + Decimal(1))
        sub_factor1_2 = (Decimal(1.0) / (Decimal(w) + Decimal(1.0)) + Decimal(1.0) / (self.t[n_shell] - Decimal(w)))
        sub_summand1 = sub_factor1_1 * sub_factor1_2

        sub_factor2_1 = (Decimal(2.0) - self.atom.Ni[n_shell] / self.atom.N[n_shell])
        sub_factor2_2 = (Decimal(1.0) / (self.t[n_shell] - Decimal(w)) ** 2 + Decimal(1.0) / (Decimal(w) + Decimal(1.0)) ** 2)
        sub_summand2 = sub_factor2_1 * sub_factor2_2

        sub_factor3_1 = self.t[n_shell].ln() / self.atom.N[n_shell]
        sub_factor3_2 = np.dot(Decimal(1.0) / (Decimal(w) + Decimal(1.0)), oscillator_strength)
        sub_summand3 = sub_factor3_1 * sub_factor3_2

        return factor * (sub_summand1 + sub_summand2 + sub_summand3)


class CrossSectionCalcBebvm(CrossSectionCalc):
    def __init__(self, T, atom=AtomFactory.get_neon()):
        CrossSectionCalc.__init__(self, T, atom)
        self.bbar = atom.B / (self.m_e * self.c ** 2)
        self.ubar = atom.U_bed / (self.m_e * self.c ** 2)
        self.beta_b = 1 - 1 / (1 + self.bbar) ** 2
        self.beta_u = 1 - 1 / (1 + self.ubar) ** 2
        self.tbar = self.T / (self.m_e * self.c ** 2)
        self.beta_t = 1 - 1 / (1 + self.tbar) ** 2
        array_elems = [elem.ln() for elem in (self.beta_t / self.beta_b)]
        value = np.sqrt(
            self.alpha ** 2
            / (self.beta_t + self.beta_b)
            * np.array(array_elems)
        )
        self.phi = decimalCos(
            value
        )
        self.f_2 = (
                -self.phi / (self.t + 1) * (1 + 2 * self.tbar) / (1 + self.tbar / 2) ** 2
        )
        self.f_3 = (
                (self.beta_t * (1 + self.tbar) ** 2).ln()
                - self.beta_t
                - (2 * np.array([elem.ln() for elem in self.bbar]))
        )

    def calculate(self):
        pass
